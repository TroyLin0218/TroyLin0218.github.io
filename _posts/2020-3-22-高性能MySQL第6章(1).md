---


layout: post

title: 【读书笔记】《高性能MySQL》第六章:查询性能优化(1)

categories: Reading-notes

description: 读书笔记

keywords: [性能优化,]
---





查询优化,索引优化,表结构优化三者需要齐头并进,本章主要讲查询优化的上半部分.

#### 1.为什么查询会慢

查询优化的实现:消除部分子任务,减少子任务的执行次数,让子任务查询的更快.

查询的生命周期:客户端 --> 服务器 --> 解析 --> 生成执行计划 --> 执行 --> 返回

其中执行包含了大量的检索数据到存储引擎的调用,以及调用后的数据处理,包括排序分组等等.

在每一个消耗大量时间的查询中,我没可以看到很多额外的操作,某些操作甚至被重复执行,这就是导致慢的主要原因.

#### 2.优化数据访问

查询速度慢的基本原因是访问的数据太多,可以通过减少访问的数据量来优化.

##### 2.1是否向数据库请求了不需要的数据

* 查询不需要的数据
  * 使用limit减少不必要的查询
* 多表关联时返回全部列
  * 关联时明确取出来的字段
* 总是取出全部列
  * 考虑是否全都需要
* 重复查询相同的数据
  * 使用缓存

##### 2.2 MySQL是否在扫描额外的数据

确定是否扫描了过多的数据,衡量查询效率的指标:

* 响应时间
* 扫描的行数
* 返回的行数

#### 3.重构查询方式

优化有问题的查询时应该考虑使用性能更好的查询来获取结果,比如使用查询转换.

##### 3.1 一个复杂查询还是多个简单查询

考虑是否把一个复杂查询改写为多个简单查询.同时数据量小的时候如果一个查询能够胜任时还写多个独立查询是不明智的

##### 3.2 切分查询

对于一个大查询,可以考虑将查询切分为小查询,每个小查询完成一小部分查询,并返回一小部分数据.例如删除数据时可以采用定期删除,而不是使用一个很大的语句一次删除,这样会锁住很多数据,占满事务日志,耗尽系统资源,阻塞很多小查询.

##### 3.3 分解关联查询

关联查询时可以采用单表查询,然后把结果放到应用程序中关联处理.这样做有很多好处:

* 让缓存的效率更高
* 分解之后的查询可以减少锁竞争
* 应用程序中关联可以将表进行拆分,便于提高性能和扩展性
* 减少冗余记录的查询

### 4.查询执行基础

查询过程:

1. 客户端发送一条查询给服务器

2. 服务器检查缓存,如果命中缓存,则立刻返回结果,否则进入下一阶段

3.  服务器进行SQL解析,预处理,再由优化器生成对应的执行计划

4. 调用存储引擎api执行查询

5. 返回结果给客户端

   

##### 4.1 MySQL客户端/服务端通信协议

MySQL客户端与服务器之间的通信协议是半双工的,这意味着在任何一个时刻,要么是由服务器向客户端发送数据,要么是由客户端向服务器发送数据,这两个动作不能同时发生.这造成了无法进行流量控制,一端开始发送之后,另一端必须接收完才能相应它.

**查询状态**
对于一个MySQL连接,或者说一个线程,任何时刻都有一个状态,该状态表示了MySQL当前正在做什么.可使用SHOW FULL PROCESSLIST命令查看当前的状态,相关的状态值：

* Sleep
  线程正在等待客户端发送新的请求.
* Query
  线程正在执行查询或者正在将结果发送给客户端
* Locked
  在MySQL服务器层,该线程正在等待表锁.存储引擎级别实现的锁,例如InnoDB的行锁,并不会体现在线程状态中.
* Analyzing and statistics
  线程正在收集存储引擎的统计信息,并生成查询的执行计划.
* Coping to tmp table [on disk]
  线程正在执行查询,并且将其结果集都复制到一个临时表中,这种状态一般要么是在GROUP BY操作,要么是文件排序操作,或者是UNION操作.若这个状态后面有”on disk”标记,那表示MySQL正在将一个内存临时表放到磁盘上.
* Sorting result
  线程正在对结果集进行排序
* Sending data
  线程可能在多个状态之间传送数据,或者生成结果集,或者在向客户端返回数据.

**MySQL能够处理的优化类型：**

- 重新定义关联表的顺序
- 将外连接转化为内连接
- 使用等价变换规则
- 优化COUNT(),MIN()和MAX()
- 预估并转化为常数表达式
- 覆盖索引扫描
- 子查询优化
- 提前终止查询
- 等值传播
- 列表IN()的比较

##### 4.2 查询缓存

MySQL内部也是有缓存的,缓存开启时如果查询命中时将会大大提高查询速度