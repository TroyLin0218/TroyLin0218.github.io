---

layout: post
title: 【读书笔记】《深入理解计算机系统》读书笔记(二)
categories: Reading-notes
description: 读书笔记
keywords: 读书笔记,CS:APP

---

## 信息的表示和处理  Round-1

#### 信息存储
##### 信息存储
大多数计算机使用8位的块或者说字节(byte)来作为最小的可寻址的内存单位(非访问内存中单独的一个位).事实上，在计算机中，内存被机器级程序(什么是机器级？关于机器级程序暂时未理解)视为一个巨大的字节数组，也就是常说的虚拟内存，这其中每个字节都由唯一的一个数据来标识，大体上可以理解为我们常用数组的下标.

##### 十六进制表示法
一个字节是8位，计算机不用二进制或者十进制来表示位模式(位模式可以简单理解为一串二进制数字)，二进制过于冗长十进制转二进制过于麻烦(虽然底层确实是用“0”“1”来表示信息)，最终先辈们选择了足够优雅的表示方式:十六进制。这时候内存这个巨大的字节数组终于有了自己优雅的门牌号.

##### 子数据大小
字长:笼统的理解为常说的“计算机是x位的”中x的值.实际上表示了指针数据的一般大小，可以理解为上面说到字节数组的门牌号，字长表示了这台机器最大的寻址空间，也就虚拟地址的大小。比如说我的笔记本是64位的，那么它的虚拟地址的范围就是0~2^64-1,程序最多可访问2^64个字节.

##### 寻址和字节顺序
理解了内存被视为一个巨大字节数组之后我们就很好理解寻址这个概念了，即在内存中找到某个变量的地址.例如y此时就指向了x的地址
```c 
int x = 0;
int *y = &x;
```
我们一般认为int型的数据占了4个字节的大小(也就是在内存中占了4个位置)，比如从0x100到0x1003这四个地址，不管上面的代码，假设x的内容十六进制下是0x01234567，在大端法和小端法中表示的是不一样的：
* 大端法:
0x1000  0x1001  0x1002  0x1003 
   01          23          45          67 
* 小端法:
 0x1000 0x1001  0x1002  0x1003 
    67	45      23    01

不同的表示方式就会导致程序的可移植性降低包括网络传输和多机器运行，同时也会影响到阅读程序.

##### c语言字符串
C 语言中字符串被编码为一个以 null（值为0）字符结尾的字符数组，每个字符都由某个标准编码表示，最常见的是 ASCII 字符码。

##### 布尔代数和位向量表示集合
位的布尔运算:0&1=0,0|1=1,异或:^ 就是相同为0,不同为1.这时候我们可以把布尔运算扩展到位向量的运算:用位向量[an,an-1,....a1,a0]来编码任何有限子集A属于{0,1....n-1,n},其中，ai表示当且仅当i属于集合A(说人话就是位向量中第i位是1就表示i在集合A中，i是从右往左数的)
举个栗子：
* a=[01101001]表示A={0，3，5，6}
* b=[01010101]表示B={0，2，4，6}
  * 那么AB的交集就是a&b=[01000001]，A∩B就是{0,6}

##### 位级运算
* 位级运算就是把二进制数据中的每一位和某个二进制数据中的每一位进行布尔运算.
  * 确定一个位级表达式的结果的最好的方法,就是将十六进制的参数扩展成二进制表示并执行运算,然后再转换成十六进制.

##### 逻辑运算
*  `&&`    `||`    `!`
* 不要和位运算混淆,
  * 逻辑运算只会返回0和1,表示false和true
  * 逻辑运算认为只要是非0都是true.


##### 移位运算
移位就是把整个数据中的位向左或向右移位k位.
* x<<k表示把x向左移k位,丢弃最高的k位,低位补k个0.
* 右移分为逻辑右移和算术右移:
  * 逻辑右移是左移的相对版,就是在左端补k个0,右端丢弃k位.
  * 算术右移是在左端补位k个最高有效位,最高有效位是0,就补k个0,这就相当于逻辑右移,如果最高位是1,就补位k个1.













